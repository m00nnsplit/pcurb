#!/usr/bin/python3
import praw
import curses
import textwrap # needed for properly presenting paragraphs
from sys import argv, stdout, stderr
from datetime import datetime # for parsing timestamps
from os import getcwd # used for the help message
from warnings import filterwarnings
filterwarnings("ignore", category=ResourceWarning)
# We get a warning because the SSL connection is not closed, but according to the PRAW people this is intentional, since the garbage collector takes care of it apparently

# structure is the same as in my ncurses labyrinth game
# we're doing argument processing inside main and reply depending on what main returns
# for now no arguments, we just start up in interactive mode


class Config :
	def __init__(self, fileName="pcurb.cfg") :
		try :
			fileStream=open(fileName)
			for workingLine in fileStream.readlines() :
				workingLine.replace(" ", "")
				words=workingLine.split("=")
				if workingLine  == "" :
					pass
				elif workingLine[0]=="#" :
					pass
				elif words[0]=="defaultSub" :
					self.defaultSub=words[1]
				elif words[0]=="nbSubsPerPage" :
					self.nbSubsPerPage=int(words[1])
				elif words[0]=="commentTreeLength" :
					self.commentTreeLength=int(words[1])

		except OSError as readError :
			self.defaultSub="blog"
			self.nbSubsPerPage=25
			self.commentTreeLength=5




# for recursivly displaying comment trees
def displayReply(commentsPad, screenMaxX, leapLines, comment, commentLevel, desiredLevel) :
	#FIXME:there's a problem somewhere, apparently when dealing with big comments
	# I think this fixed it :
	# basically a problem with MoreComments instead of Comment
	if not isinstance(comment, praw.objects.Comment):
		commentsPad.addstr(leapLines, commentLevel*2, "[More Comments]")
		return leapLines+1

	
	wrapper=textwrap.TextWrapper(width=(screenMaxX-1-(commentLevel*2)))
	try:
		commentsPad.addstr(leapLines,commentLevel*2,"---- "+str(comment.score)+" : "+str(comment.author)+"["+comment.author_flair_text+"]")
	except TypeError: #no flair
		commentsPad.addstr(leapLines,commentLevel*2,"---- "+str(comment.score)+" : "+str(comment.author))
	leapLines=leapLines+1
	for i in str.splitlines(comment.body) :
		for j in wrapper.wrap(i) :
			commentsPad.addstr(leapLines, commentLevel*2,j)
			leapLines=leapLines+1
	if desiredLevel>commentLevel :
		for k in comment.replies :
			leapLines=displayReply(commentsPad, screenMaxX, leapLines+1, k, commentLevel+1, desiredLevel)
	return leapLines


# when a submission is opened, this function opens a new window and generates everything inside
def displayComments(standardScreen, screenMaxY, screenMaxX, titleWin, submissionsPad, reddit, currentSubreddit, submissionToOpen, submissionsNumberLimit):
	# we open a new window with the contents of the submission
	submissions = reddit.get_subreddit(currentSubreddit).get_hot(limit=submissionsNumberLimit)
	yCoordComments = 0
	xCoordComments = 0
	
	submissionsPad.erase()
	commentsPad = curses.newpad(200*100, screenMaxX+1) #200 is the max number of connents reddit loads at once and 100 is what I hope is the mean number or lines they'll take
	for i in range(int(submissionToOpen)+1) :
		submissionWeAreLookingAt = next(submissions)

	leapLines = 0
	wrapper=textwrap.TextWrapper(width=screenMaxX-1)#, drop_whitespace=False)#replace_whitespace=False)
	#TODO:replace_whitespace eats words, the textrwrap doc suggests use of str.splitlines()

	try:
		subText = "["+submissionWeAreLookingAt.link_flair_text+"]"+submissionWeAreLookingAt.title
	except TypeError: #no flair
		subText = submissionWeAreLookingAt.title

	for l in wrapper.wrap(subText) :
		commentsPad.addstr(leapLines,0, l)
		leapLines=leapLines+1

	leapLines=leapLines+1
	commentsPad.addstr(leapLines,0,"Score: "+str(submissionWeAreLookingAt.score)+", with "+str(submissionWeAreLookingAt.num_comments)+" comments")
	leapLines=leapLines+1

	try :
		commentsPad.addstr(leapLines,0, "By "+str(submissionWeAreLookingAt.author)+"["+submissionWeAreLookingAt.author_flair_text+"]"+" at "+str(datetime.fromtimestamp(submissionWeAreLookingAt.created)))
	except TypeError : # no flair
		commentsPad.addstr(leapLines,0, "By "+str(submissionWeAreLookingAt.author)+" at "+str(datetime.fromtimestamp(submissionWeAreLookingAt.created)))

	leapLines=leapLines+2



	commentsPad.addstr(leapLines,0,"Permalink: "+submissionWeAreLookingAt.permalink[:screenMaxX-1-len("Permalink: ")])
	for l in wrapper.wrap(submissionWeAreLookingAt.permalink[screenMaxX-1-len("Permalink: "):]) :
		leapLines=leapLines+1
		commentsPad.addstr(leapLines,0,l)

	leapLines=leapLines+2


	commentLevel=0

	if submissionWeAreLookingAt.selftext=="" : # no text
		if submissionWeAreLookingAt.permalink != submissionWeAreLookingAt.url :
			#hopefully, this should filter out textless self posts
			commentsPad.addstr(leapLines,0,"Linking to: "+submissionWeAreLookingAt.url[:screenMaxX-1-len("Linking to: ")])
			for l in wrapper.wrap(submissionWeAreLookingAt.url[screenMaxX-1-len("Linking to: "):]) :
				leapLines=leapLines+1
				commentsPad.addstr(leapLines,0,l)
		else :
			commentsPad.addstr(leapLines,0,"[no text]")
		leapLines=leapLines+2

	else :
		for k in str.splitlines(submissionWeAreLookingAt.selftext) :
			for l in wrapper.wrap(k) :
				commentsPad.addstr(leapLines, 0, l)
				leapLines=leapLines+1
	leapLines=leapLines+1

	for i in submissionWeAreLookingAt.comments :
		try :
			leapLines=displayReply(commentsPad, screenMaxX, leapLines, i, commentLevel, 3)
			leapLines=leapLines+1 #let's skip one more
		except AttributeError :
		#it's a MoreComments
			leapLines=leapLines+1 
	commentsPad.addstr(leapLines+2,0,"== End of comments ==");#TODO: find a better way to prevent user scrolling into the abyss
	commentsPad.refresh(yCoordComments,0,3,1,screenMaxY-1,screenMaxX-1)
	titleWin.addstr(1,screenMaxX-16, "               ")
	titleWin.refresh()
	
	while True :
		standardScreen.refresh()
		commentsPad.refresh(yCoordComments,0,3,1,screenMaxY-1,screenMaxX-1)

		userInput = standardScreen.getch()

		if userInput == curses.KEY_DOWN :
			if yCoordComments< (200*100 - screenMaxY-1) :
				yCoordComments = yCoordComments+1
		elif userInput == curses.KEY_UP :
			if yCoordComments>0 :
				yCoordComments = yCoordComments-1

		elif userInput == curses.KEY_PPAGE : #page up
			if (yCoordComments-(screenMaxY-3))>=0 :
				yCoordComments = yCoordComments-(screenMaxY-3)+3
			else :
				yCoordComments = 0;
		elif userInput == curses.KEY_NPAGE : #page down
			if (yCoordComments+(screenMaxY-3))<(200*100-(screenMaxY-3)) :
				yCoordComments = yCoordComments+(screenMaxY-3)-3

		elif userInput == ord('q') or userInput==ord('Q') :
			break







def main(standardScreen, reddit) :
	#TODO : use the Config class and the pcurb.cfg file

	# no arguments -> interactive mode
	if len(argv) > 1 :
		if argv[1] == 'help' or argv[1] == 'h' or argv[1] == '-h' :
			return 'help'

		else :
			currentSubreddit = argv[1]
			pass 	
		pass
	else :
		currentSubreddit = 'Announcements'
	



	curses.curs_set(False)
	curses.use_default_colors()
	screenMaxY, screenMaxX = standardScreen.getmaxyx()
	standardScreen.clear()

	submissionsNumberLimit = 25

	yCoord = 0

	# titleWin displays current subreddit
	titleWin = standardScreen.subwin(3, screenMaxX, 0,0)
	titleWin.border()

	titleWin.addstr(1,1, "Sub : "+currentSubreddit)


	submissionsPad = curses.newpad(submissionsNumberLimit*5+2, screenMaxX+1) #submissions number limit times lines per submission

	
	submissionsPad.addstr(0,0,"Fetching submissions..")
	standardScreen.refresh()
	submissionsPad.refresh(yCoord,0,3,1,screenMaxY-1,screenMaxX-1)

	submissions = reddit.get_subreddit(currentSubreddit).get_hot(limit=submissionsNumberLimit)

	while True :


		k=0
		subIndice = 0
		for subIter in submissions :
			try:
				subText = "["+subIter.link_flair_text+"]"+subIter.title +" ("+str(subIter.score)+"pts|"+str(subIter.num_comments)+"coms)"
			except TypeError: #no flair
				subText = subIter.title +" ("+str(subIter.score)+"pts|"+str(subIter.num_comments)+"coms)"
			if len(subText)+4<screenMaxX :
				subHeightLines = 1
				submissionsPad.addstr(k, 0, str(subIndice)+'] '+subText)
			#if a submission title is more than 4 lines, well..
			elif len(subText)+4<screenMaxX*2 :
				subHeightLines = 2
				submissionsPad.addstr(k,0,str(subIndice)+'] '+subText[:screenMaxX-5])
				submissionsPad.addstr(k+1,0,subText[screenMaxX-5:])
			
			elif len(subText)+4<screenMaxX*3 :
				subHeightLines = 3
				submissionsPad.addstr(k,0,str(subIndice)+'] '+subText[:screenMaxX-5])
				submissionsPad.addstr(k+1,0,subText[screenMaxX-5:screenMaxX*2-5])
				submissionsPad.addstr(k+2,0,subText[screenMaxX*2-6:screenMaxX*3])

			elif len(subText)+4<screenMaxX*4 :
				subHeightLines = 4
				submissionsPad.addstr(k,0,str(subIndice)+'] '+subText[:screenMaxX-5])
				submissionsPad.addstr(k+1,0,subText[screenMaxX-5:screenMaxX*2-5])
				submissionsPad.addstr(k+2,0,subText[screenMaxX*2-6:screenMaxX*3-5])
				submissionsPad.addstr(k+2,0,subText[screenMaxX*3-6:screenMaxX*4])

			submissionsPad.addstr(k+subHeightLines,0,'----------')
			k=k+subHeightLines+1
			subIndice=subIndice+1



		standardScreen.refresh()
		submissionsPad.refresh(yCoord,0,3,1,screenMaxY-1,screenMaxX-1)

		userInput = standardScreen.getch()

		if userInput == curses.KEY_DOWN :
			if yCoord< (submissionsNumberLimit*2 - screenMaxY +2+3) :
				yCoord = yCoord+1
		elif userInput == curses.KEY_UP :
			if yCoord>0 :
				yCoord = yCoord-1

		elif userInput == ord('m') or userInput == ord('M') :
			# M for 'more', type number of a submission to read it
			submissionToOpen = standardScreen.getstr()
			#TODO : use something a bit more sophisticated than getstr()
			#return str(int(submissionToOpen))
			try :
				if int(submissionToOpen)<submissionsNumberLimit:
					titleWin.addstr(1, screenMaxX-15, "Loading no"+str(int(submissionToOpen)))
					titleWin.refresh()
					displayComments(standardScreen, screenMaxY, screenMaxX, titleWin, submissionsPad, reddit, currentSubreddit, submissionToOpen, submissionsNumberLimit)
					submissions = reddit.get_subreddit(currentSubreddit).get_hot(limit=submissionsNumberLimit)
					standardScreen.refresh()
			except ValueError :
				pass
	
		elif userInput == ord('q') or userInput == ord('Q') :
			break


			


appVersion = 'testing v1'

reddit = praw.Reddit(user_agent='PCURB:'+appVersion+' (by /u/m00nnsplit)')
errorType = curses.wrapper(main, reddit)

if errorType == "help" :
	print("ncurses & PRAW -based console reddit browser in Python 3")
	print("pass subreddit name as argument")
	print("please read "+getcwd()+"/readme file for more details")
	exit()
#else :
#	print("error : "+errorType)
#	exit()
