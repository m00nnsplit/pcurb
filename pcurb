#!/usr/bin/python3
import praw
import curses
import textwrap # needed for properly presenting paragraphs
from sys import argv, stdout, stderr
from datetime import datetime # for parsing timestamps
from os import getcwd # used for the help message
from warnings import filterwarnings
filterwarnings("ignore", category=ResourceWarning)
# We get a warning because the SSL connection is not closed, but according to the PRAW people this is intentional, since the garbage collector takes care of it apparently

# structure is the same as in my ncurses labyrinth game
# we're doing argument processing inside main and reply depending on what main returns
# for now no arguments, we just start up in interactive mode


class Config :
	def __init__(self, fileName="pcurb.cfg") :
		try :
			fileStream=open(fileName)
			for workingLine in fileStream.readlines() :
				workingLine.replace(" ", "")
				words=workingLine.split("=")
				if workingLine  == "" :
					pass
				elif workingLine[0]=="#" :
					pass
				elif words[0]=="defaultSub" :
					self.defaultSub=words[1]
				elif words[0]=="nbSubsPerPage" :
					self.nbSubsPerPage=int(words[1])
				elif words[0]=="commentTreeLength" :
					self.commentTreeLength=int(words[1])

		except OSError as readError :
			self.defaultSub="blog"
			self.nbSubsPerPage=25
			self.commentTreeLength=5




# for recursivly displaying comment trees
def displayReply(commentsPad, screenMaxX, leapLines, comment, commentLevel, desiredLevel) :
	#FIXME:there's a problem somewhere, apparently when dealing with big comments
	# I think this fixed it :
	# basically a problem with MoreComments instead of Comment
	if not isinstance(comment, praw.objects.Comment):
		commentsPad.addstr(leapLines, commentLevel*2, "[More Comments]")
		return leapLines+1

	
	wrapper=textwrap.TextWrapper(width=(screenMaxX-1-(commentLevel*2)))

	commentsPad.addstr(leapLines,commentLevel*2,"---- "+str(comment.score)+" : "+str(comment.author))
	leapLines=leapLines+1
	for i in str.splitlines(comment.body) :
		for j in wrapper.wrap(i) :
			commentsPad.addstr(leapLines, commentLevel*2,j)
			leapLines=leapLines+1
	if desiredLevel>commentLevel :
		for k in comment.replies :
			leapLines=displayReply(commentsPad, screenMaxX, leapLines+1, k, commentLevel+1, desiredLevel)
	return leapLines


# when a submission is opened, this function opens a new window and generates everything inside
def displayComments(standardScreen, screenMaxY, screenMaxX, titleWin, submissionsPad, reddit, currentSubreddit, submissionToOpen, submissionsNumberLimit):
	# we open a new window with the contents of the submission
	submissions = reddit.get_subreddit(currentSubreddit).get_hot(limit=submissionsNumberLimit)
	yCoordComments = 0
	xCoordComments = 0
	
	submissionsPad.erase()
	commentsPad = curses.newpad(200*100, screenMaxX+1) #200 is the max number of connents reddit loads at once and 100 is what I hope is the mean number or lines they'll take
	for i in range(int(submissionToOpen)+1) :
		submissionWeAreLookingAt = next(submissions)
	commentsPad.addstr(0,0, str(submissionWeAreLookingAt))
	commentsPad.addstr(1,0, "By "+str(submissionWeAreLookingAt.author)+" at "+str(datetime.fromtimestamp(submissionWeAreLookingAt.created)))
	#commentsPad.addstr(0,0,praw.helpers.flatten_tree(submissionWeAreLookingAt.comments)[0].body)	


	commentLevel=0
	leapLines = 3
	wrapper=textwrap.TextWrapper(width=screenMaxX-1)#, drop_whitespace=False)#replace_whitespace=False)
	#TODO:replace_whitespace eats words, the textrwrap doc suggests use of str.splitlines()


	try :
		for k in str.splitlines(submissionWeAreLookingAt.selftext) :
			for l in wrapper.wrap(k) :
				commentsPad.addstr(leapLines, 0, l)
				leapLines=leapLines+1
	except AttributeError : # no selftext
		#FIXME: doesn't seem to work
		commentsPad.addstr(leapLines,0,"[no text]")
		leapLines=leapLines+1
	leapLines=leapLines+1

	for i in submissionWeAreLookingAt.comments :
		try :
			leapLines=displayReply(commentsPad, screenMaxX, leapLines, i, commentLevel, 3)
			leapLines=leapLines+1 #let's skip one more
		except AttributeError :
		#it's a MoreComments
			leapLines=leapLines+1 
	commentsPad.addstr(leapLines+2,0,"==EOC==");#TODO: find a better way to prevent user scrolling into the abyss
	commentsPad.refresh(yCoordComments,0,3,1,screenMaxY-1,screenMaxX-1)
	titleWin.addstr(1,screenMaxX-16, "               ")
	titleWin.refresh()
	
	while True :
		standardScreen.refresh()
		commentsPad.refresh(yCoordComments,0,3,1,screenMaxY-1,screenMaxX-1)

		userInput = standardScreen.getch()

		if userInput == curses.KEY_DOWN :
			if yCoordComments< (200*100 - screenMaxY-1) :
				yCoordComments = yCoordComments+1
		elif userInput == curses.KEY_UP :
			if yCoordComments>0 :
				yCoordComments = yCoordComments-1
		elif userInput == ord('q') or userInput==ord('Q') :
			break







def main(standardScreen, reddit) :
	#TODO : use the Config class and the pcurb.cfg file

	# no arguments -> interactive mode
	if len(argv) > 1 :
		if argv[1] == 'help' or argv[1] == 'h' or argv[1] == '-h' :
			return 'help'

		else :
			currentSubreddit = argv[1]
			pass 	
		pass
	else :
		currentSubreddit = 'Announcements'
	



	curses.curs_set(False)
	curses.use_default_colors()
	screenMaxY, screenMaxX = standardScreen.getmaxyx()
	standardScreen.clear()

	submissionsNumberLimit = 25

	yCoord = 0

	# titleWin displays current subreddit
	titleWin = standardScreen.subwin(3, screenMaxX, 0,0)
	titleWin.border()

	titleWin.addstr(1,1, "Sub : "+currentSubreddit)


	submissionsPad = curses.newpad(submissionsNumberLimit*2+1, screenMaxX+1) #submissions number limit times lines per submission

	
	submissionsPad.addstr(0,0,"Fetching submissions..")
	standardScreen.refresh()
	submissionsPad.refresh(yCoord,0,3,1,screenMaxY-1,screenMaxX-1)

	submissions = reddit.get_subreddit(currentSubreddit).get_hot(limit=submissionsNumberLimit)

	while True :


		k=0
		for subIter in submissions :
			#return str(subIter)
			submissionsPad.addstr(k*2, 0, str(k)+'] '+str(subIter))
			submissionsPad.addstr(k*2+1,0,'----------')
			k=k+1



		standardScreen.refresh()
		submissionsPad.refresh(yCoord,0,3,1,screenMaxY-1,screenMaxX-1)

		userInput = standardScreen.getch()

		if userInput == curses.KEY_DOWN :
			if yCoord< (submissionsNumberLimit*2 - screenMaxY +2+3) :
				yCoord = yCoord+1
		elif userInput == curses.KEY_UP :
			if yCoord>0 :
				yCoord = yCoord-1

		elif userInput == ord('m') or userInput == ord('M') :
			# M for 'more', type number of a submission to read it
			submissionToOpen = standardScreen.getstr()
			#TODO : use something a bit more sophisticated than getstr()
			#return str(int(submissionToOpen))
			try :
				if int(submissionToOpen)<submissionsNumberLimit:
					titleWin.addstr(1, screenMaxX-15, "Loading no"+str(int(submissionToOpen)))
					titleWin.refresh()
					displayComments(standardScreen, screenMaxY, screenMaxX, titleWin, submissionsPad, reddit, currentSubreddit, submissionToOpen, submissionsNumberLimit)
					submissions = reddit.get_subreddit(currentSubreddit).get_hot(limit=submissionsNumberLimit)
					standardScreen.refresh()
			except ValueError :
				pass
	
		elif userInput == ord('q') or userInput == ord('Q') :
			break


			


appVersion = 'testing v1'

reddit = praw.Reddit(user_agent='PCURB:'+appVersion+' (by /u/m00nnsplit)')
errorType = curses.wrapper(main, reddit)

if errorType == "help" :
	print("ncurses & PRAW -based console reddit browser in Python 3")
	print("pass subreddit name as argument")
	print("please read "+getcwd()+"/readme file for more details")
	exit()
#else :
#	print("error : "+errorType)
#	exit()
